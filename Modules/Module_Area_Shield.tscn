[gd_scene load_steps=7 format=2]

[ext_resource path="res://Modules/Module_Area_Shield.gd" type="Script" id=1]
[ext_resource path="res://Effects/ShieldGlow.tscn" type="PackedScene" id=2]

[sub_resource type="CanvasItemMaterial" id=1]
blend_mode = 1

[sub_resource type="Gradient" id=2]

[sub_resource type="Shader" id=3]
code = "shader_type canvas_item;

//Parameters
uniform float shield_radius = 0.0;
uniform float shield_width = 0.0;
uniform float hit_angle = 0.0;
uniform float hit_fade = 0.0;

//Shock
const vec4 shock_white = vec4(0.88, 0.97, 1.00, 1.00);
const vec4 shock_color = vec4(0.32, 0.78, 1.00, 1.00);
uniform float shock_strength = 1.0;

//Shield
const vec4 shield_color_a = vec4(0.31, 0.70, 1.0, 0.58);
const vec4 shield_color_b = vec4(0.0, 0.23, 0.54, 0.68);
uniform float shield_strength = 0.0;
uniform float shield_charging = 0.0;
const vec4 shield_damage_color = vec4(1,1,1,1);

//Shield Damage
uniform float shield_damage_strength = 0.0;

//Noise
uniform vec2 offset;
const float simplex_scale = 0.25;
const int OCTAVES = 5;

float _clamp_radians(float r) {
	while(r > 3.141592)
	{
		r = r - 2.0 * 3.141592;
	}
	while(r < -1.0 * 3.141592)
	{
		r = r + 2.0 * 3.141592;
	}
	return r;
}

float _radian_distance(float a, float b) {
	float t1 = 0.0;
	float t2 = 0.0;
	float d1 = 0.0;
	float d2 = 0.0;
	float d = 0.0;
	a = _clamp_radians(a);
	b = _clamp_radians(b);
	if(a < b)
	{
		t1 = a;
		t2 = b;
	}
	else
	{
		t1 = b;
		t2 = a;
	}
	d1 = t2 - t1;
	d2 = t1 + 2.0 * 3.141592 - t2;
	if(d1 < d2)
	{
		d = d1;
	}
	else
	{
		d = d2;
	}
	return d;
}

float rand(vec2 coord){
	return fract(sin(dot(coord, vec2(12.9898, 78.233)))* 43758.5453123);
	//return fract(sin(dot(coord, vec2(56.0934483, 78.3674596)) * 1000.0) * 1000.0);
}

vec3 mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289_2(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
    return mod289_3(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
    vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                  0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                 -0.577350269189626,  // -1.0 + 2.0 * C.x
                  0.024390243902439); // 1.0 / 41.0
    // First corner
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    
    // Other corners
    vec2 i1;
    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
    //i1.y = 1.0 - i1.x;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    // x0 = x0 - 0.0 + 0.0 * C.xx ;
    // x1 = x0 - i1 + 1.0 * C.xx ;
    // x2 = x0 - 1.0 + 2.0 * C.xx ;
    vec4 x12 = vec4(x0.xy, x0.xy) + C.xxzz;
    x12.xy -= i1;
    
    // Permutations
    i = mod289_2(i); // Avoid truncation effects in permutation
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    	+ i.x + vec3(0.0, i1.x, 1.0 ));
    
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), vec3(0.0));
    m = m*m ;
    m = m*m ;
    
    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
    
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    
    // Normalise gradients implicitly by scaling m
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    
    // Compute final noise value at P
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

float fbm(vec2 coord){
	float value = 0.0;
	float scale = 0.8;
	vec2 new_offset = offset;

	for(int i = 0; i < OCTAVES; i++){
		value += snoise((coord + new_offset) * simplex_scale);
		coord *= 2.0;
		scale *= 0.75;
	}
	value = value / float(OCTAVES) + 0.5;
	value = clamp(value,0.0,1.0);
	return value;
}

vec4 shock(vec4 original, vec2 uv, vec2 noiseuv, float time)
{
	vec2 coord = noiseuv * 8.0;
	vec4 new_col = original;
	
	float noise1 = fbm(coord + vec2(time * -0.3, time * 0.3));
	float noise2 = fbm(coord + vec2(0, time * -0.6));
	float combined = (noise1 + noise2) / 2.0;
	float shock_width = 0.175;
	float shock_input = shock_strength * 0.9 + 0.1;
	combined = pow(combined, shock_input);
	new_col = vec4(vec3(combined), 1.0);
	
	if (combined > 0.5 - shock_width && combined < 0.5 + shock_width) {
		if(combined < 0.5)
		{
			new_col = mix(shock_white, shock_color, (0.5 - combined) / shock_width);
			new_col = mix(new_col, original, (0.5 - combined) / shock_width);
		}
		if(combined > 0.5)
		{
			new_col = mix(shock_color, shock_white, 1.0 - (combined - 0.5) / shock_width);
			new_col = mix(original, new_col, 1.0 - (combined - 0.5) / shock_width);
			/*new_col.a = 1.0 - 2.0 * (combined - 0.5) / shock_width;
			if(new_col.a < 0.2)
			{
				new_col.a = 0.0;
			}*/
		}
	} else {
		new_col = original;
	}
	new_col.a *= original.a;
	return new_col;
}

vec4 circle(vec4 original, vec2 uv, vec2 tps)
{
	vec4 new_col = original;
	vec2 center = vec2(.5,.5);
	vec2 pixels = vec2(1.0 / tps.x, 1.0 / tps.y);
	float d = 0.0;
	float outer = shield_radius / pixels.x;
	float inner = (shield_radius - shield_width) / pixels.y;
	float middle = inner + .5 * (outer - inner);
	
	d = distance(uv,center);
	if(d <= outer && d >= inner)
	{
		//new_col = vec4(0.0, 0.0, 0.0, 1.0);
		new_col = shield_color_a;
		new_col.a = 1.0 - abs(middle - d) / (0.5 * (outer - inner));
		//new_col.a = new_col.a * new_col.a
	}
	return new_col;
}

vec4 shield_fade(vec4 original, vec2 uv)
{
	vec4 new_col = original;
	vec2 center = vec2(.5,.5);
	float theta = atan(uv.y - center.y, uv.x - center.x);
	float d = 0.0;
	if(hit_fade > 0.0)
	{
		d = _radian_distance(theta, hit_angle);
		d = d / hit_fade;
		new_col.a = hit_fade * (2.0 * new_col.a - abs(2.0 * d));
		if(new_col.a < 0.0)
		{
			new_col.a = 0.0;
		}
	}
	else
	{
		new_col.a = 0.0;
	}
	return new_col;
}

void fragment()
{
	vec4 current_texture;
	vec2 outp;
	vec2 noiseuv = UV;
	vec2 moduv = vec2(0,0);
	
	moduv = UV;
	
	current_texture = texture(TEXTURE,moduv);
	COLOR = current_texture;
	
	COLOR = circle(current_texture, moduv, TEXTURE_PIXEL_SIZE);
	
	if(true)
	{
		//COLOR = shock(COLOR, moduv, noiseuv, TIME);
	}
	COLOR = shield_fade(COLOR, moduv);
	//COLOR = vec4(1.0, 0.0, 0.0, 1.0);
}"

[sub_resource type="ShaderMaterial" id=4]
resource_local_to_scene = true
shader = SubResource( 3 )
shader_parameter/shield_radius = 128.0
shader_parameter/shield_width = 32.0
shader_parameter/hit_angle = 0.0
shader_parameter/hit_fade = 1.0
shader_parameter/shock_strength = 1.0
shader_parameter/shield_strength = 0.0
shader_parameter/shield_charging = 0.0
shader_parameter/shield_damage_strength = 0.0
shader_parameter/offset = null

[node name="Module_Area_Shield" type="ColorRect"]
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
margin_left = -960.0
margin_top = -540.0
margin_right = -952.0
margin_bottom = -532.0
color = Color( 1, 1, 1, 0 )
script = ExtResource( 1 )
shield = 100
max_shield = 100
shield_radius = 128
shield_width = 48

[node name="Shield_Line" type="Line2D" parent="."]
visible = false
light_mask = 0
material = SubResource( 1 )
default_color = Color( 0.54902, 0.811765, 1, 0.498039 )
gradient = SubResource( 2 )

[node name="ShieldGlow" parent="." instance=ExtResource( 2 )]
material = SubResource( 4 )
position = Vector2( 0, 0 )
script = null
